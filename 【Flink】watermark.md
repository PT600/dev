## Watermark的传递

* Watermark为真实的特殊的数据
* 合并时，取最小的watermaker，通过空闲等待时间控制的上游watermaker的更新
* watermaker通过广播形式传递

## 迟到数据
* 触发计算和关闭窗口是分开的
* 每个迟到数据会触发一次计算
* 关闭窗口后可以使用侧边输出流


## 1、乱序与迟到的区别
    * 乱序: 数据的顺序乱了， 时间小的 比 时间大的 
    * 晚来迟到: 数据的时间戳< 当前的watermark

## 2、乱序、迟到数据的处理
    * watermark 中指定 乱序等待时间
    * 如果开窗，设置窗口允许迟到
        推迟关窗时间，在关窗之前，迟到数据来了，还能被窗口计算，来一条迟到数据触发一次计算
        关后，迟到数据不会被计算
    * 关窗后的迟到数据，放入侧输出流

如果 watermark 等待3s， 窗口允许迟到2s，为什么不直接 watermark 等待5s 或 窗口允许迟到5s ?
    * watermark 等待时间不会设太大 影响的计算延迟=》
        如果3s ==》 口第一次触发计算和输出，13s的数据来13-3=10s15s的数据来
        如果5s ==》 口第一次触发计算和输出15-5=10s尽量让结果准确
    * 窗口口允许迟到，是对 大部分迟到数据的 处理，=》如果只设置 允许迟到5s，那么 就会导致 频繁 重新输出

## 设置经验
1. watermark等待时间，设置一个不算特别大的，一般是秒级，在 乱序和 延迟 取舍
2. 设置一定的窗口允许迟到，只考虑大部分的迟到数据，
3. 极端小部分迟到很久的数据，不管2 、3、极端小部分迟到很久的数据， 放到侧输出流。 获取到之后可以做各种处理

## 总结
1. 80%情况正常数据处理
2. 15%乱序使用watermark解决、
3. 4%的迟到数据使用窗口允许迟到解决
4. 1%的迟到很久数据，使用侧输出流


## WaterMark和key无关
## WaterMark也是数据，在process里面获取的watermark是上条数据的watermark。


## 定时器
* keyed才有
* 事件时间定时器，通过watermark来触发
    watermark >= 注册的时间
    注意: watermark = 当前最大事件时间 - 等待时间 -1ms， 因为 -1ms，所以会推迟一条数据
    比如，5s的定时器，如果 等待=3s， watermark = 8s - 3s -1ms = 4999ms,不会触发5s的定时器需要 
    watermark = 9s -3s -1ms = 5999ms ，才能去触发 5s的定时器
* 在process中获取当前watermark，显示的是上一次的watermark
    因为process还没接收到这条数据对应生成的新watermark


## 聚合函数会去掉前面的窗口性质